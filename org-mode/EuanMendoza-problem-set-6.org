#+title: Problem Set 6
#+author: Euan Mendoza

<<ce42d2e1-b5fd-44ce-b48a-5dbc9543ebb2>>
* Homework Assignment Notebook - Discrete Quantum Walks
:PROPERTIES:
:CUSTOM_ID: homework-assignment-notebook---discrete-quantum-walks
:END:

<<31c04130-bb0e-46c6-859b-4631c9b4ed34>>
This notebook, containing all required deliverables, should be submitted
for the Discrete Quantum Walk module homework assignment.

<<1874a871-5f69-4524-97cb-57fc70ab4a02>>
The quantum equivalent of the random walk process can be established by
defining a "Coin Flip" operator, \(C\), and a "Shift" operator, \(S\).

\[
C := \sum_{j\in V} |j\rangle\langle j| \otimes
(2|\partial_j\rangle\langle\partial_j| - I),\\
S :=
\sum_{(j,k)\in E}|j,k\rangle\langle k,j|.
\]

By applying these two operators many times in succession, we establish
the equivalence of the random walk in the quantum realm.

<<bd7a5c38-c657-4837-af23-5833b0c9ab1f>>
** Your Assignment:
:PROPERTIES:
:CUSTOM_ID: your-assignment
:END:

<<8784f328-c664-48e7-a2b9-86c3ead473a0>>
Using the Qmod example from the lecture (4-node cycle), inspired by
Andrew Childs'
[[https://www.cs.umd.edu/~amchilds/qa/qa.pdf][lecture notes]] (pp.
89--90), design a quantum walk operator for a 16-node line:

<<83f417a5-7cd1-4d6f-b92f-075cc20c936c>>

#+begin_html
  <div style="text-align:center;">
      <img src="https://docs.classiq.io/resources/linear_graph_16_nodes.png" alt="Linear 16-node Graph" />
  </div>
#+end_html

<<06c9689d-e982-4523-bb97-4de7edf36365>>
Use the in-class quantum walk circle example code and Child's lecture
notes as your starting point.

You may extend it beyond the assignment's requirements and class
coverage, generalizing your code into a general-purpose algorithm that
handles all cases.

<<4d4c8502-9b99-4cfa-90f1-66020bf5570d>>
Your code and explanations should be included in the following section,
which provides a step-by-step outline of what needs to be submitted.

<<05f506ff-7710-4c19-b11f-fb2c51053adf>>

** Your Solution:
:PROPERTIES:
:CUSTOM_ID: your-solution
:END:

#+begin_src python
from classiq import *
#+end_src

#+begin_src python
#TODO: Insert your solution here, it should be written by you, 
# including checking that your algorithm produces the correct results.
# Good luck!

size = 2

@qfunc
def prepare_minus(aux: Output[QBit]):
  allocate(1,aux)
  X(aux)
  H(aux)

@qfunc
def diffuser_oracle(aux: QNum, x: QNum):
  aux ^= (x!=0)

@qfunc
def zero_diffuser(x: QNum):
  aux = QBit('aux')
  within_apply(lambda: prepare_minus(aux),
              lambda: diffuser_oracle(aux,x))
# Newer option to do the oracle and preparation within one line with control and phase

@qfunc
def C_operator(vertices: QNum, adjacent_vertices: QNum):
    for i in range(2**size):
      prob = [0,0,0,0]
      prob[(i+1)% 4]=0.5
      prob[(i-1)% 4]=0.5
      control(vertices==i,
              lambda: within_apply(
              lambda: inplace_prepare_state(probabilities=prob, bound=0.01, target=adjacent_vertices),
              lambda: zero_diffuser(adjacent_vertices)))

@qfunc
def edge_oracle(res:Output[QBit], vertices: QNum, adjacent_vertices: QNum):
  res |= (((vertices+adjacent_vertices)%2) ==1)


@qfunc 
def bitwise_swap(x: QArray[QBit], y:QArray[QBit]):
  for i in range(x.len):
   SWAP(x[i],y[i])
  

@qfunc 
def S_operator(vertices:QNum, adjacent_vertices: QNum):
    res = QNum('res')
    edge_oracle(res,vertices,adjacent_vertices) 
    control(res==1,
        lambda: bitwise_swap(vertices,adjacent_vertices))
    free(res)

@qfunc 
def main(vertices: Output[QNum], adjacent_vertices:Output[QNum]):
    allocate(size, vertices)
  inplace_prepare_state(probabilities=[1,0,0,0], bound=0.01, target=vertices),
  
    allocate(size, adjacent_vertices)
  inplace_prepare_state(probabilities=[0,1,0,0], bound=0.01, target=adjacent_vertices),
  C_operator(vertices,adjacent_vertices)
  S_operator(vertices,adjacent_vertices)

qmod = create_model(main)
qprog = synthesize(qmod)
show(qprog)

#+end_src

#+begin_example
Quantum program link: https://platform.classiq.io/circuit/34jVQ42jynReRterwLQ5EmSBiiT
#+end_example

#+begin_src jupyter-python
# Number of nodes in a graph
N = 15
#+end_src

<<bc089452-c243-405b-8d11-9e1469f2dc15>>
Don't forget to verify that your algorithm works for several initial
states!

<<3a990f56-3ee8-4b5d-adca-489ca5f053eb>>
Please upload this notebook with your solution via the submission form
sent to you.
